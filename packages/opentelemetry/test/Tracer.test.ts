import * as NodeSdk from "@effect/opentelemetry/NodeSdk"
import * as Tracer from "@effect/opentelemetry/Tracer"
import { assert, describe, expect, it } from "@effect/vitest"
import * as OtelApi from "@opentelemetry/api"
import { AsyncHooksContextManager } from "@opentelemetry/context-async-hooks"
import { InMemorySpanExporter, SimpleSpanProcessor } from "@opentelemetry/sdk-trace-base"
import * as Console from "effect/Console"
import * as Effect from "effect/Effect"
import * as FiberRef from "effect/FiberRef"
import * as Layer from "effect/Layer"
import * as Runtime from "effect/Runtime"
import { OtelSpan } from "../src/internal/tracer.js"

class Exporter extends Effect.Service<Exporter>()("Exporter", {
  effect: Effect.sync(() => ({ exporter: new InMemorySpanExporter() }))
}) {}

const TracingLive = Layer.unwrapEffect(Effect.gen(function*() {
  const { exporter } = yield* Exporter

  return NodeSdk.layer(Effect.sync(() => ({
    resource: {
      serviceName: "test"
    },
    spanProcessor: [new SimpleSpanProcessor(exporter)]
  })))
})).pipe(Layer.provideMerge(Exporter.Default))

// needed to test context propagation
const contextManager = new AsyncHooksContextManager()
OtelApi.context.setGlobalContextManager(contextManager)

describe("Tracer", () => {
  describe("provided", () => {
    it.effect("withSpan", () =>
      Effect.provide(
        Effect.withSpan("ok")(
          Effect.gen(function*() {
            const span = yield* Effect.currentSpan
            expect(span).instanceOf(OtelSpan)
          })
        ),
        TracingLive
      ))

    it.effect("withSpan links", () =>
      Effect.gen(function*() {
        const linkedSpan = yield* Effect.makeSpanScoped("B")
        const span = yield* Effect.currentSpan.pipe(
          Effect.withSpan("A"),
          Effect.linkSpans(linkedSpan)
        )
        assert(span instanceof OtelSpan)
        expect(span.links.length).toBe(1)
      }).pipe(
        Effect.scoped,
        Effect.provide(TracingLive)
      ))

    it.effect("supervisor sets context", () =>
      Effect.provide(
        Effect.withSpan("ok")(
          Effect.sync(() => {
            expect(OtelApi.trace.getSpan(OtelApi.context.active())).toBeDefined()
          })
        ),
        TracingLive
      ))

    it.effect("supervisor sets context generator", () =>
      Effect.gen(function*() {
        yield* Effect.yieldNow()
        expect(OtelApi.trace.getSpan(OtelApi.context.active())).toBeDefined()
      }).pipe(
        Effect.withSpan("ok"),
        Effect.provide(TracingLive)
      ))

    it.effect("currentOtelSpan", () =>
      Effect.provide(
        Effect.withSpan("ok")(
          Effect.gen(function*() {
            const span = yield* Effect.currentSpan
            const otelSpan = yield* Tracer.currentOtelSpan
            expect((span as OtelSpan).span).toBe(otelSpan)
          })
        ),
        TracingLive
      ))

    it.scoped("withSpanContext", () =>
      Effect.gen(function*() {
        const effect = Effect.gen(function*() {
          const span = yield* Effect.currentParentSpan
          assert(span._tag === "Span")
          const parent = yield* span.parent
          return parent
        }).pipe(Effect.withSpan("child"))

        const runtime = yield* Effect.runtime()

        yield* Effect.promise(async () => {
          await OtelApi.trace.getTracer("test").startActiveSpan("otel-span", {
            root: true,
            attributes: { "root": "yes" }
          }, async (span) => {
            try {
              const parent = await Runtime.runPromise(
                runtime,
                Tracer.withSpanContext(
                  effect,
                  span.spanContext()
                )
              )
              const { spanId, traceId } = span.spanContext()
              expect(parent).toMatchObject({
                spanId,
                traceId
              })
            } finally {
              span.end()
            }
          })
        })
      }).pipe(Effect.provide(TracingLive)))
  })

  describe("not provided", () => {
    it.effect("withSpan", () =>
      Effect.withSpan("ok")(
        Effect.gen(function*() {
          const span = yield* Effect.currentSpan
          expect(span).not.instanceOf(OtelSpan)
        })
      ))
  })

  describe("Log Attributes", () => {
    it.effect("propagates attributes with Effect.fnUntraced", () =>
      Effect.gen(function*() {
        const f = Effect.fnUntraced(function*() {
          yield* Effect.logWarning("FooBar")
          return yield* Effect.fail("Oops")
        })

        const p = f().pipe(Effect.withSpan("p"))

        yield* Effect.ignore(p)

        const { exporter } = yield* Exporter

        assert.isNotEmpty(exporter.getFinishedSpans()[0].events.filter((_) => _.name === "FooBar"))
        assert.isNotEmpty(exporter.getFinishedSpans()[0].events.filter((_) => _.name === "exception"))
      }).pipe(Effect.provide(TracingLive)))

    it.effect("propagates attributes with Effect.fn(name)", () =>
      Effect.gen(function*() {
        const f = Effect.fn("f")(function*() {
          yield* Effect.logWarning("FooBar")
          return yield* Effect.fail("Oops")
        })

        const p = f().pipe(Effect.withSpan("p"))

        yield* Effect.ignore(p)

        const { exporter } = yield* Exporter

        assert.isNotEmpty(exporter.getFinishedSpans()[0].events.filter((_) => _.name === "FooBar"))
        assert.isNotEmpty(exporter.getFinishedSpans()[0].events.filter((_) => _.name === "exception"))
      }).pipe(Effect.provide(TracingLive)))

    it.effect("propagates attributes with Effect.fn", () =>
      Effect.gen(function*() {
        const f = Effect.fn(function*() {
          yield* Effect.logWarning("FooBar")
          return yield* Effect.fail("Oops")
        })

        const p = f().pipe(Effect.withSpan("p"))

        yield* Effect.ignore(p)

        const { exporter } = yield* Exporter

        yield* Console.log(Array.from(yield* FiberRef.get(FiberRef.currentLoggers)))

        assert.isNotEmpty(exporter.getFinishedSpans()[0].events.filter((_) => _.name === "FooBar"))
        assert.isNotEmpty(exporter.getFinishedSpans()[0].events.filter((_) => _.name === "exception"))
      }).pipe(Effect.provide(TracingLive)))
  })
})
