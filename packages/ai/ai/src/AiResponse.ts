/**
 * @since 1.0.0
 */
import type * as Context from "effect/Context"
import { dual } from "effect/Function"
import * as Option from "effect/Option"
import * as Predicate from "effect/Predicate"
import * as Schema from "effect/Schema"
import type * as AiTool from "./AiTool.js"
import * as InternalCommon from "./internal/common.js"

const constDisableValidation: Schema.MakeOptions = { disableValidation: true }

// =============================================================================
// Provider Metadata
// =============================================================================

/**
 * A record containing all valid provider metadata keys which can be used to
 * extract provider-specific metadata from components of a response.
 *
 * @since 1.0.0
 * @category Provider Options
 */
export const ProviderMetadata = {
  MetadataPart: "@effect/ai/AiResponse/ProviderMetadata/MetadataPart",
  TextPart: "@effect/ai/AiResponse/ProviderMetadata/TextPart",
  FilePart: "@effect/ai/AiResponse/ProviderMetadata/FilePart",
  ReasoningPart: "@effect/ai/AiResponse/ProviderMetadata/ReasoningPart",
  ToolCallPart: "@effect/ai/AiResponse/ProviderMetadata/ToolCallPart",
  ToolCallResultPart: "@effect/ai/AiResponse/ProviderMetadata/ToolCallResultPart",
  UrlSourcePart: "@effect/ai/AiResponse/ProviderMetadata/UrlSourcePart",
  DocumentSourcePart: "@effect/ai/AiResponse/ProviderMetadata/DocumentSourcePart",
  FinishPart: "@effect/ai/AiResponse/ProviderMetadata/FinishPart"
} as const satisfies Record<string, ProviderMetadata.AllKeys>

/**
 * A utility type to extract provider-specific metadata from a record at the
 * specified key.
 *
 * @since 1.0.0
 * @category Utility Types
 */
export type ExtractProviderMetadata<
  Metadata extends Record<string, any>,
  Key extends ProviderMetadata.AllKeys
> = Key extends keyof Metadata ? Metadata[Key] : never

/**
 * @since 1.0.0
 */
export declare namespace ProviderMetadata {
  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type AllKeys =
    | MetadataPart
    | TextPart
    | FilePart
    | ReasoningPart
    | ToolCallPart
    | ToolCallResultPart
    | DocumentSourcePart
    | UrlSourcePart
    | FinishPart

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type MetadataPart = "@effect/ai/AiResponse/ProviderMetadata/MetadataPart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type TextPart = "@effect/ai/AiResponse/ProviderMetadata/TextPart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type FilePart = "@effect/ai/AiResponse/ProviderMetadata/FilePart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type ReasoningPart = "@effect/ai/AiResponse/ProviderMetadata/ReasoningPart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type ToolCallPart = "@effect/ai/AiResponse/ProviderMetadata/ToolCallPart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type ToolCallResultPart = "@effect/ai/AiResponse/ProviderMetadata/ToolCallResultPart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type DocumentSourcePart = "@effect/ai/AiResponse/ProviderMetadata/DocumentSourcePart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type UrlSourcePart = "@effect/ai/AiResponse/ProviderMetadata/UrlSourcePart"

  /**
   * @since 1.0.0
   * @category Provider Metadata Keys
   */
  export type FinishPart = "@effect/ai/AiResponse/ProviderMetadata/FinishPart"
}

// =============================================================================
// Parts
// =============================================================================

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const PartTypeId: unique symbol = Symbol.for("@effect/ai/AiResponse/Part")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type PartTypeId = typeof PartTypeId

/**
 * Represents the identifier generated by a model when a tool call is requested.
 *
 * @since 1.0.0
 * @category Models
 */
export const ToolCallId: Schema.brand<typeof Schema.String, "@effect/ai/ToolCallId"> = InternalCommon.ToolCallId

/**
 * @since 1.0.0
 * @category Models
 */
export type ToolCallId = typeof ToolCallId.Type

/**
 * Represents the base part type which all other parts inherit from.
 *
 * @since 1.0.0
 * @category Models
 */
export abstract class BasePart extends Schema.Class<BasePart>(
  "@effect/ai/AiResponse/BasePart"
)({
  /**
   * Additional provider-specific metadata which can be returned from the
   * provider integration and used to enable provider-specific behavior.
   */
  providerMetadata: Schema.optionalWith(
    Schema.Record({
      key: Schema.String,
      value: Schema.Record({
        key: Schema.String,
        value: Schema.Unknown
      })
    }),
    { default: () => ({}) }
  )
}) {
  /**
   * @since 1.0.0
   */
  readonly [PartTypeId] = PartTypeId

  /**
   * Gets the provider-specific metadata for this part of the prompt, if
   * present.
   */
  abstract getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.AllKeys>>

  /**
   * Sets the provider-specific metadata for this part of the prompt.
   */
  abstract setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.AllKeys>
  ): BasePart
}

/**
 * Represents metadata about the response.
 *
 * @since 1.0.0
 * @category Models
 */
export class MetadataPart extends BasePart.extend<MetadataPart>(
  "@effect/ai/AiResponse/MetadataPart"
)({
  type: Schema.tag("metadata"),
  /**
   * The generated identifier for the generated response, if the large language
   * model provider returns one in the response.
   */
  id: Schema.optional(Schema.String),

  /**
   * The timestamp of the generated response, if the large language model
   * provider returns one in the response.
   */
  timestamp: Schema.optional(Schema.DateFromSelf),

  /**
   * The identifier of the model used to generate the response, if the large
   * language model provider returns one in the response.
   */
  modelId: Schema.optional(Schema.String)
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.MetadataPart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.MetadataPart>
  ): MetadataPart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new MetadataPart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents a text part of a response which contains a string of text.
 *
 * @since 1.0.0
 * @category Models
 */
export class TextPart extends BasePart.extend<TextPart>(
  "@effect/ai/AiResponse/TextPart"
)({
  type: Schema.tag("text"),
  /**
   * The text content of the part.
   */
  text: Schema.String
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.TextPart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.TextPart>
  ): TextPart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new TextPart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents a file that has been generated by the large language model which
 * contains data for a file as eithera `Uint8Array` or a base64 encoded string.
 *
 * File data should be returned from the provider as-is, without unnecessary
 * conversion.
 *
 * @since 1.0.0
 * @category Partss
 */
export class FilePart extends BasePart.extend<FilePart>(
  "@effect/ai/AiResponse/FilePart"
)({
  type: Schema.tag("file"),
  /**
   * The IANA media type of the file (e.g. `"image/png"`, `"application/pdf"`).
   *
   * @see https://www.iana.org/assignments/media-types/media-types.xhtml
   */
  mediaType: Schema.String,
  /**
   * The file data as either a `Uint8Array` or a base64 encoded string.
   */
  data: Schema.Union(
    Schema.String,
    Schema.Uint8ArrayFromSelf
  )
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.FilePart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.FilePart>
  ): FilePart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new FilePart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents reasoning text that was generated by the large language model.
 *
 * @since 1.0.0
 * @category Partss
 */
export class ReasoningPart extends BasePart.extend<ReasoningPart>(
  "@effect/ai/AiResponse/ReasoningPart"
)({
  type: Schema.tag("reasoning"),
  /**
   * The reasoning text generated by the large language model.
   */
  text: Schema.String
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.ReasoningPart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.ReasoningPart>
  ): ReasoningPart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new ReasoningPart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents a tool call part of the prompt which indicates a tool that the
 * large language model requested. The result of the tool call is used to
 * augment the large language model's final response.
 *
 * @since 1.0.0
 * @category Partss
 */
export class ToolCallPart extends BasePart.extend<ToolCallPart>(
  "@effect/ai/AiResponse/ToolCallPart"
)({
  type: Schema.tag("tool-call"),
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  id: ToolCallId,
  /**
   * The name of the tool to call.
   */
  name: Schema.String,
  /**
   * The parameters to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  params: Schema.Unknown,
  /**
   * The mode in which this tool call will be executed.
   * - `"client"`: indicates that the tool call will be executed by the
   *   client application
   * - `"server"`: indicates that the tool call will be executed by the large
   *   language model provider
   *
   * If this property is not set, the `mode` of tool call execution will
   * default to `"client"`.
   */
  mode: Schema.optionalWith(
    Schema.Literal("client", "server"),
    { default: () => "client" as const }
  )
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.ToolCallPart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.ToolCallPart>
  ): ToolCallPart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new ToolCallPart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents a tool call result which is included in the prompt to allow the
 * large language model to incorporate the result into its next response.
 *
 * @since 1.0.0
 * @category Partss
 */
export class ToolCallResultPart extends BasePart.extend<ToolCallResultPart>(
  "@effect/ai/AiResponse/ToolCallResultPart"
)({
  type: Schema.tag("tool-result"),
  /**
   * The identifier of the tool call with which this tool call result is
   * associated.
   */
  id: ToolCallId,
  /**
   * The name of the tool call with which this tool call result is associated.
   */
  name: Schema.String,
  /**
   * The pre-encoded result of the tool call as a JSON-serializable value.
   */
  result: Schema.Unknown,
  /**
   * The mode in which this tool call was executed.
   * - `"client"`: indicates that the tool call was be executed by the
   *   client application
   * - `"server"`: indicates that the tool call was executed by the large
   *   language model provider
   *
   * If this property is not set, the `mode` of tool call execution will
   * default to `"client"`.
   */
  mode: Schema.optionalWith(
    Schema.Literal("client", "server"),
    { default: () => "client" as const }
  )
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.ToolCallResultPart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.ToolCallResultPart>
  ): ToolCallResultPart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new ToolCallResultPart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents a document source that was used as input by the large language model
 * to generate the response.
 *
 * @since 1.0.0
 * @category Parts
 */
export class DocumentSourcePart extends BasePart.extend<DocumentSourcePart>(
  "@effect/ai/AiResponse/Sources/Document"
)({
  type: Schema.tag("source"),
  /**
   * The type of source that was used to generate the content.
   */
  sourceType: Schema.tag("document"),
  /**
   * The identifier for the document source.
   */
  id: Schema.String,
  /**
   * The IANA media type of the dcoument (e.g. `"application/pdf"`).
   */
  mediaType: Schema.String,
  /**
   * The title of the document source.
   */
  title: Schema.String,
  /**
   * The optional filename of the document.
   */
  filename: Schema.optional(Schema.String),
  /**
   * Provider-specific metadata associated with the document source.
   */
  providerMetadata: Schema.optionalWith(
    Schema.Record({
      key: Schema.String,
      value: Schema.Record({ key: Schema.String, value: Schema.Unknown })
    }),
    { default: () => ({}) }
  )
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.DocumentSourcePart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.DocumentSourcePart>
  ): DocumentSourcePart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new DocumentSourcePart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents a URL source that was used as input by the large language model
 * to generate the response.
 *
 * @since 1.0.0
 * @category Parts
 */
export class UrlSourcePart extends BasePart.extend<UrlSourcePart>(
  "@effect/ai/AiResponse/Sources/Url"
)({
  type: Schema.tag("source"),
  /**
   * The type of source that was used to generate the content.
   */
  sourceType: Schema.tag("url"),
  /**
   * The identifier for the URL source.
   */
  id: Schema.String,
  /**
   * The URL of the source.
   */
  url: Schema.URL,
  /**
   * The optional title of the URL source.
   */
  title: Schema.optional(Schema.String),
  /**
   * Provider-specific metadata associated with the URL source.
   */
  providerMetadata: Schema.optionalWith(
    Schema.Record({
      key: Schema.String,
      value: Schema.Record({ key: Schema.String, value: Schema.Unknown })
    }),
    { default: () => ({}) }
  )
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.UrlSourcePart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.UrlSourcePart>
  ): UrlSourcePart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new UrlSourcePart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents the reason why a model finished generation of a response.
 *
 * Possible finish reasons:
 * - `"stop"`: The model generated a stop sequence.
 * - `"length"`: The model exceeded its token budget.
 * - `"content-filter"`: The model generated content which violated a content filter.
 * - `"tool-calls"`: The model triggered a tool call.
 * - `"error"`: The model encountered an error.
 * - `"other"`: The model stopped for a reason not supported by this protocol.
 * - `"unknown"`: The model did not specify a finish reason.
 *
 * @since 1.0.0
 * @category Models
 */
export const FinishReason: Schema.Literal<[
  "stop",
  "length",
  "content-filter",
  "tool-calls",
  "error",
  "other",
  "unknown"
]> = Schema.Literal(
  "stop",
  "length",
  "content-filter",
  "tool-calls",
  "error",
  "other",
  "unknown"
)

/**
 * @since 1.0.0
 * @category Models
 */
export type FinishReason = typeof FinishReason.Type

/**
 * Represents usage information for a request to a large language model provider.
 *
 * If the model provider returns additional usage information than what is
 * specified here, you can generally find that information under the provider
 * metadata of the finish part of the response.
 *
 * @since 1.0.0
 * @category Models
 */
export class Usage extends Schema.Class<Usage>("@effect/ai/AiResponse/Usage")({
  /**
   * The number of tokens sent in the request to the model.
   */
  inputTokens: Schema.UndefinedOr(Schema.Number),
  /**
   * The number of tokens that the model generated for the request.
   */
  outputTokens: Schema.UndefinedOr(Schema.Number),
  /**
   * The total of number of input tokens and output tokens as reported by the
   * large language model provider.
   *
   * **NOTE**: This value may differ from the sum of `inputTokens` and
   * `outputTokens` due to inclusion of reasoning tokens or other
   * provider-specific overhead.
   */
  totalTokens: Schema.UndefinedOr(Schema.Number),
  /**
   * The number of reasoning tokens that the model used to generate the output
   * for the request.
   */
  reasoningTokens: Schema.optionalWith(Schema.Number, { exact: true }),
  /**
   * The number of input tokens read from the prompt cache for the request.
   */
  cachedInputTokens: Schema.optionalWith(Schema.Number, { exact: true })
}) {}

/**
 * Represents the final part of the response generated by the large language
 * model provider which contains summary data about the response (usage
 * information, finish reason, etc.).
 *
 * @since 1.0.0
 * @category Parts
 */
export class FinishPart extends BasePart.extend<FinishPart>(
  "@effect/ai/AiResponse/FinishPart"
)({
  type: Schema.tag("finish"),
  /**
   * The usage information for the response.
   */
  usage: Usage,
  /**
   * The reason the model finished generating a response.
   */
  reason: FinishReason
}) {
  getProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>
  ): Option.Option<ExtractProviderMetadata<Metadata, ProviderMetadata.FinishPart>> {
    return Option.fromNullable(this.providerMetadata[tag.key]) as any
  }

  setProviderMetadata<Identifier, Metadata extends Record<string, any>>(
    tag: Context.Tag<Identifier, Metadata>,
    metadata: ExtractProviderMetadata<Metadata, ProviderMetadata.FinishPart>
  ): FinishPart {
    const providerMetadata = { ...this.providerMetadata, [tag.key]: metadata }
    return new FinishPart({ ...this, providerMetadata }, constDisableValidation)
  }
}

/**
 * Represents the different parts which can be included in the response from a
 * large language model provider.
 *
 * @since 1.0.0
 * @category Parts
 */
export const Part: Schema.Union<[
  typeof MetadataPart,
  typeof TextPart,
  typeof FilePart,
  typeof ReasoningPart,
  typeof ToolCallPart,
  typeof ToolCallResultPart,
  typeof DocumentSourcePart,
  typeof UrlSourcePart,
  typeof FinishPart
]> = Schema.Union(
  MetadataPart,
  TextPart,
  FilePart,
  ReasoningPart,
  ToolCallPart,
  ToolCallResultPart,
  DocumentSourcePart,
  UrlSourcePart,
  FinishPart
)
/**
 * @since 1.0.0
 * @category Parts
 */
export type Part = typeof Part.Type

/**
 * @since 1.0.0
 * @category Guards
 */
export const isPart = (u: unknown): u is Part => Predicate.hasProperty(u, PartTypeId)

// =============================================================================
// Response
// =============================================================================

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const TypeId: unique symbol = Symbol.for("@effect/ai/AiResponse")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type TypeId = typeof TypeId

/**
 * Represents a response from a large language model provider.
 *
 * A response contains an array of response parts which correspond to the
 * content generated by the large language model.
 *
 * @since 1.0.0
 * @category Responses
 */
export class AiResponse extends Schema.Class<AiResponse>(
  "@effect/ai/AiResponse"
)({
  /**
   * The parts of the generated response received from the large language model.
   */
  parts: Schema.Array(Part)
}) {
  /**
   * @since 1.0.0
   */
  readonly [TypeId] = TypeId

  /**
   * Returns the generated text content of the response.
   */
  get text(): string {
    let text = ""
    for (const part of this.parts) {
      if (part.type === "text") {
        text += part.text
      }
    }
    return text
  }

  /**
   * Returns the finish reason for the response, or `"unknown"` if the finish
   * reason is not known.
   */
  get finishReason(): FinishReason {
    const finishPart = this.parts.find((part) => part.type === "finish")
    return finishPart?.reason ?? "unknown"
  }

  /**
   * Returns all tool calls contained within the response.
   */
  get toolCalls(): ReadonlyArray<ToolCallPart> {
    return this.parts.filter((part) => part.type === "tool-call")
  }
}

/**
 * @since 1.0.0
 * @category Constructors
 */
export const empty: AiResponse = new AiResponse(
  { parts: [] },
  constDisableValidation
)

/**
 * @since 1.0.0
 * @category Guards
 */
export const isResponse = (u: unknown): u is AiResponse => Predicate.hasProperty(u, TypeId)

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const WithToolCallResultsTypeId: unique symbol = Symbol.for("@effect/ai/AiResponse/WithToolCallResults")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type WithToolCallResultsTypeId = typeof WithToolCallResults

/**
 * Represents a response generated by a large language model that includes the
 * results of tool calls.
 *
 * @since 1.0.0
 * @category Responses
 */
export class WithToolCallResults<Tools extends Record<string, AiTool.Any>> extends AiResponse {
  /**
   * @since 1.0.0
   */
  readonly [WithToolCallResultsTypeId] = WithToolCallResultsTypeId

  /**
   * The tool call results, represented as a mapping between the tool call
   * identifier and the result of the tool call handler.
   */
  readonly results: ReadonlyMap<
    ToolCallId,
    {
      [Name in keyof Tools]: {
        readonly name: Name
        readonly result: AiTool.Success<Tools[Name]>
      }
    }[keyof Tools]
  >

  /**
   * The pre-encoded tool call results as JSON-serializable values suitable for
   * incorporation into subsequent requests to the large language model.
   */
  readonly encodedResults: ReadonlyMap<
    ToolCallId,
    {
      [Name in keyof Tools]: {
        readonly name: Name
        readonly result: unknown
      }
    }[keyof Tools]
  >

  constructor(props: {
    /**
     * The parts of the generated response received from the large language model.
     */
    readonly parts: ReadonlyArray<Part>
    /**
     * The tool call results, represented as a mapping between the tool call
     * identifier and the result of the tool call handler.
     */
    readonly results: ReadonlyMap<
      ToolCallId,
      {
        [Name in keyof Tools]: {
          readonly name: Name
          readonly result: AiTool.Success<Tools[Name]>
        }
      }[keyof Tools]
    >
    /**
     * The pre-encoded tool call results as JSON-serializable values suitable for
     * incorporation into subsequent requests to the large language model.
     */
    readonly encodedResults: ReadonlyMap<
      ToolCallId,
      {
        [Name in keyof Tools]: {
          readonly name: Name
          readonly result: unknown
        }
      }[keyof Tools]
    >
  }, options?: Schema.MakeOptions) {
    super({ parts: props.parts }, options)
    this.results = props.results
    this.encodedResults = props.encodedResults
  }

  /**
   * Returns the result of the tool call with the specified name, if present.
   */
  getToolCallResult<Name extends keyof Tools>(name: Name): Option.Option<AiTool.Success<Tools[Name]>> {
    for (const entry of this.results.values()) {
      if (entry.name === name) {
        return Option.some(entry.result)
      }
    }
    return Option.none()
  }
}

/**
 * @since 1.0.0
 * @category Guards
 */
export const hasToolCallResults = (u: unknown): u is WithToolCallResults<Record<string, AiTool.Any>> =>
  Predicate.hasProperty(u, WithToolCallResultsTypeId)

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const WithStructuredOutputTypeId = Symbol.for("@effect/ai/AiResponse/WithStructuredOutput")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type WithStructuredOutputTypeId = typeof WithStructuredOutputTypeId

/**
 * Represents a response generated by a large language model that includes
 * structured output.
 *
 * @since 1.0.0
 * @category Responses
 */
export class WithStructuredOutput<Value> extends AiResponse {
  /**
   * @since 1.0.0
   */
  readonly [WithStructuredOutputTypeId] = WithStructuredOutputTypeId

  /**
   * The identifier of the tool which generated the structured output.
   */
  readonly id: ToolCallId

  /**
   * The name of the tool which generated the structured output.
   */
  readonly name: string

  /**
   * The structured output value generated by the model.
   */
  readonly value: Value

  constructor(props: {
    /**
     * The parts of the generated response received from the large language model.
     */
    readonly parts: ReadonlyArray<Part>
    /**
     * The identifier of the tool which generated the structured output.
     */
    readonly id: ToolCallId
    /**
     * The name of the tool which generated the structured output.
     */
    readonly name: string
    /**
     * The structured output value generated by the model.
     */
    readonly value: Value
  }, options?: Schema.MakeOptions) {
    super({ parts: props.parts }, options)
    this.id = props.id
    this.name = props.name
    this.value = props.value
  }
}

/**
 * @since 1.0.0
 * @category Guards
 */
export const hasStructuredOutput = (u: unknown): u is WithStructuredOutput<any> =>
  Predicate.hasProperty(u, WithStructuredOutputTypeId)

/**
 * Combines two responses into a single response.
 *
 * @since 1.0.0
 * @category Combination
 */
export const merge: {
  (other: AiResponse): (self: AiResponse) => AiResponse
  (self: AiResponse, other: AiResponse): AiResponse
} = dual<
  (other: AiResponse) => (self: AiResponse) => AiResponse,
  (self: AiResponse, other: AiResponse) => AiResponse
>(2, (self, other) => {
  const newParts = mergeParts(self, other)
  if (hasToolCallResults(self) && hasToolCallResults(other)) {
    return new WithToolCallResults({
      results: new Map([...self.results, ...other.results]) as any,
      encodedResults: new Map([...self.encodedResults, ...other.encodedResults]),
      parts: newParts
    }, constDisableValidation)
  } else if (hasToolCallResults(self)) {
    return new WithToolCallResults({
      results: self.results as any,
      encodedResults: self.encodedResults,
      parts: newParts
    }, constDisableValidation)
  } else if (hasToolCallResults(other)) {
    return new WithToolCallResults({
      results: other.results as any,
      encodedResults: other.encodedResults,
      parts: newParts
    }, constDisableValidation)
  } else if (hasStructuredOutput(self) && hasStructuredOutput(other)) {
    return new WithStructuredOutput({
      id: self.id,
      name: self.name,
      value: other.value,
      parts: newParts
    }, constDisableValidation)
  } else if (hasStructuredOutput(self)) {
    return new WithStructuredOutput({
      id: self.id,
      name: self.name,
      value: self.value,
      parts: newParts
    }, constDisableValidation)
  } else if (hasStructuredOutput(other)) {
    return new WithStructuredOutput({
      id: other.id,
      name: other.name,
      value: other.value,
      parts: newParts
    }, constDisableValidation)
  }
  return new AiResponse({ parts: newParts }, constDisableValidation)
})

const mergeParts = (self: AiResponse, other: AiResponse): ReadonlyArray<Part> => {
  if (self.parts.length === 0) {
    return other.parts.slice()
  }
  if (other.parts.length === 0) {
    return self.parts.slice()
  }
  const parts: Array<Part> = []
  for (const part of self.parts) {
    parts.push(part)
  }
  for (const part of other.parts) {
    parts.push(part)
  }
  return parts
}
