/**
 * @since 1.0.0
 */
import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import * as Predicate from "effect/Predicate"
import * as Schema from "effect/Schema"
import { AiError } from "./AiError.js"
import * as InternalCommon from "./internal/common.js"

const constDisableValidation = { disableValidation: true } as const

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const TypeId: unique symbol = Symbol("@effect/ai/AiResponse")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type TypeId = typeof TypeId

/**
 * Represents a single response received from a large language model.
 *
 * @since 1.0.0
 * @category Models
 */
export class AiResponse extends Schema.Class<AiResponse>(
  "@effect/ai/AiResponse"
)({
  /**
   * The conversational role of the message generated by the model.
   */
  role: Schema.Literal("assistant").pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() => "assistant" as const)
  ),
  /**
   * The parts of the response generated by the model.
   */
  parts: Schema.Array(Schema.suspend(() => Part))
}) {
  /**
   * @since 1.0.0
   */
  readonly [TypeId]: TypeId = TypeId

  /**
   * @since 1.0.0
   */
  static is(u: unknown): u is AiResponse {
    return Predicate.hasProperty(u, TypeId)
  }

  /**
   * @since 1.0.0
   */
  static empty = new AiResponse({ parts: [] }, constDisableValidation)

  /**
   * Creates an `AiResponse` from text content.
   * @since 1.0.0
   */
  static fromText(content: string): AiResponse {
    return new AiResponse({
      parts: [new TextPart({ content }, constDisableValidation)]
    }, constDisableValidation)
  }

  /**
   * The text content of the response.
   */
  get text(): string {
    let text = ""
    let found = false
    for (const part of this.parts) {
      if (part._tag === "Text") {
        text += found ? "\n\n" + part.content : part.content
        found = true
      }
    }
    return text
  }

  /**
   * Combines two responses into a single response.
   */
  merge(other: AiResponse): AiResponse {
    if (other.parts.length === 0) {
      return new AiResponse({
        role: this.role,
        parts: this.parts
      }, constDisableValidation)
    }
    if (this.parts.length === 0) {
      return new AiResponse({
        role: other.role,
        parts: other.parts
      }, constDisableValidation)
    }
    const lastPart = this.parts[this.parts.length - 1]
    const newParts: Array<Part> = []
    let content = lastPart._tag === "Text" ? lastPart.content : ""
    for (const part of other.parts) {
      if (part._tag === "Text") {
        content += part.content
      }
    }
    if (content.length > 0) {
      newParts.push(new TextPart({ content }, constDisableValidation))
    }
    return newParts.length === 0 ? this : new AiResponse({
      role: other.role,
      parts: [...this.parts.slice(0, this.parts.length - 1), ...newParts]
    }, constDisableValidation)
  }

  /**
   * Adds the specified array of tool calls to the response.
   *
   * @since 1.0.0
   */
  withToolCallsJson(
    toolCalls: Iterable<{
      readonly id: string
      readonly name: string
      readonly params: string
    }>
  ): Effect.Effect<AiResponse, AiError> {
    return Effect.map(
      Effect.forEach(toolCalls, (toolCall) => ToolCallPart.fromJson(toolCall)),
      (parts) =>
        new AiResponse({
          role: this.role,
          parts: [...this.parts, ...parts]
        }, constDisableValidation)
    )
  }

  /**
   * Adds the specified array of tool calls to the response.
   *
   * @since 1.0.0
   */
  withToolCallsUnknown(
    toolCalls: Iterable<{
      readonly id: string
      readonly name: string
      readonly params: unknown
    }>
  ): AiResponse {
    return new AiResponse({
      role: this.role,
      parts: Array.from(toolCalls).map((part) => ToolCallPart.fromUnknown(part))
    }, constDisableValidation)
  }
}

/**
 * Represents a content source that was used to generate a model response.
 *
 * @since 1.0.0
 * @category Models
 */
export class ContentSourceAnnotation extends Schema.TaggedClass<ContentSourceAnnotation>(
  "@effect/ai/AiResponse/Annotation/ContentSourceAnnotation"
)("ContentSourceAnnotation", {
  /**
   * The identifier for the content source.
   */
  id: Schema.String,
  /**
   * The index of the content source in the list of sources provided in the
   * model request parameters.
   */
  index: Schema.Int,
  /**
   * The provider-specific type of the file annotation.
   *
   * For example, when using Anthropic the type may be `char_location`,
   * `page_location`, or `content_block_location`.
   */
  type: Schema.String,
  /**
   * The content used from the content source in the message generated by the
   * model.
   */
  referencedContent: Schema.String,
  /**
   * The index of the first character of the content referenced by the content
   * source in the message generated by the model.
   */
  startIndex: Schema.Int,
  /**
   * The index of the last character of the content referenced by the content
   * source in the message generated by the model.
   */
  endIndex: Schema.Int
}) {}

/**
 * Represents a file that was used to generate a model response.
 *
 * @since 1.0.0
 * @category Models
 */
export class FileAnnotation extends Schema.TaggedClass<FileAnnotation>(
  "@effect/ai/AiResponse/Annotation/FileAnnotation"
)("FileAnnotation", {
  /**
   * The identifier for the file.
   */
  id: Schema.String,
  /**
   * The provider-specific type of the file annotation.
   *
   * For example, when using OpenAi the type may be `file_citation` or
   * `file_path`.
   */
  type: Schema.String,
  /**
   * The index of the file in the list of files provided in the model request
   * parameters.
   */
  index: Schema.Int
}) {}

/**
 * Represents a web resource that was used to generate a model response.
 *
 * @since 1.0.0
 * @category Models
 */
export class UrlAnnotation extends Schema.TaggedClass<UrlAnnotation>(
  "@effect/ai/AiResponse/Annotation/UrlAnnotation"
)("UrlAnnotation", {
  /**
   * The URL of the web resource.
   */
  url: Schema.String,
  /**
   * The title of the web resource.
   */
  title: Schema.String,
  /**
   * The index of the first character of the content referenced by the web
   * resource in the message generated by the model.
   */
  startIndex: Schema.Int,
  /**
   * The index of the last character of the content referenced by the web
   * resource in the message generated by the model.
   */
  endIndex: Schema.Int
}) {}

/**
 * Represents annotations that were used to support the message generated by
 * a model.
 *
 * @since 1.0.0
 * @category Models
 */
export const Annotation: Schema.Union<[
  typeof ContentSourceAnnotation,
  typeof FileAnnotation,
  typeof UrlAnnotation
]> = Schema.Union(
  ContentSourceAnnotation,
  FileAnnotation,
  UrlAnnotation
).annotations({ identifier: "@effect/ai/AiResponse/CitationPart" })

/**
 * @since 1.0.0
 * @category Models
 */
export type Annotation = typeof Annotation.Type

/**
 * Represents part of the text generated by the model.
 *
 * @since 1.0.0
 * @category Models
 */
export class TextPart extends Schema.TaggedClass<TextPart>(
  "@effect/ai/AiResponse/TextPart"
)("Text", {
  /**
   * The text content generated by the model.
   */
  content: Schema.String,
  /**
   * The annotations used to support the text generated by the model.
   */
  annotations: Schema.optionalWith(Schema.Array(Annotation), {
    default: () => []
  })
}) {}

/**
 * Represents part of the reasoning carried out by the model to generate a
 * response.
 *
 * @since 1.0.0
 * @category Models
 */
export class ReasoningPart extends Schema.TaggedClass<ReasoningPart>(
  "@effect/ai/AiResponse/ReasoningPart"
)("Reasoning", {
  /**
   * The reasoning content that the model used to return the output.
   */
  reasoning: Schema.String,
  /**
   * An optional signature which verifies that the reasoning text was generated
   * by the model.
   */
  signature: Schema.optional(Schema.String)
}) {}

/**
 * Represents part of the reasoning carried out by the model to generate a
 * response which needed to be encrypted by the model provider for safety
 * reasons.
 *
 * @since 1.0.0
 * @category Models
 */
export class RedactedReasoningPart extends Schema.TaggedClass<RedactedReasoningPart>(
  "@effect/ai/AiResponse/RedactedReasoningPart"
)("RedactedReasoning", {
  /**
   * The content in the reasoning that was encrypted by the model provider for
   * safety reasons.
   */
  redactedContent: Schema.String
}) {}

/**
 * Represents the identifier generated by a model when a tool call is requested.
 *
 * @since 1.0.0
 * @category Models
 */
export const ToolCallId: Schema.brand<typeof Schema.String, "ToolCallId"> = InternalCommon.ToolCallId

/**
 * @since 1.0.0
 * @category Models
 */
export type ToolCallId = typeof ToolCallId.Type

/**
 * Represents a request by a model to call a specific tool that it has been
 * provided with.
 *
 * @since 1.0.0
 * @category Models
 */
export class ToolCallPart extends Schema.TaggedClass<ToolCallPart>(
  "@effect/ai/AiResponse/ToolCallPart"
)("ToolCall", {
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  id: ToolCallId,
  /**
   * The name of the tool to call.
   */
  name: Schema.String,
  /**
   * The arguments to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  params: Schema.Unknown
}) {
  /**
   * Convert a tool call `id`, `name`, and `params` into a `ToolCallPart` by
   * parsing the string `params`.
   *
   * @since 1.0.0
   */
  static fromJson({ id, name, params }: {
    readonly id: string
    readonly name: string
    readonly params: string
  }): Effect.Effect<ToolCallPart, AiError> {
    return Effect.try({
      try: () =>
        new ToolCallPart({
          id: ToolCallId.make(id),
          name,
          params: JSON.parse(params)
        }, constDisableValidation),
      catch: (cause) =>
        new AiError({
          module: "AiResponse",
          method: "ToolCall.fromJson",
          description: "Failed to parse parameters",
          cause
        })
    })
  }

  /**
   * Convert a tool call `id`, `name`, and `params` into a `ToolCallPart`.
   *
   * @since 1.0.0
   */
  static fromUnknown({ id, name, params }: {
    readonly id: string
    readonly name: string
    readonly params: unknown
  }): ToolCallPart {
    return new ToolCallPart({
      id: ToolCallId.make(id),
      name,
      params
    }, constDisableValidation)
  }
}

/**
 * Represents the initial response metadata generated by a model when responding
 * to a request.
 *
 * @since 1.0.0
 * @categor Models
 */
export class ResponseMetadataPart extends Schema.TaggedClass<ResponseMetadataPart>(
  "@effect/ai/AiResponse/ResponseMetadataPart"
)("ResponseMetadata", {
  /**
   * The unique identifier for the response. Each chunk of the response should
   * have the same identifier.
   */
  id: Schema.optional(Schema.String),
  /**
   * The model that was used to generate the response.
   */
  model: Schema.String,
  /**
   * The Unix timestamp of when the model began generated the response.
   */
  timestamp: Schema.ValidDateFromSelf
}) {}

/**
 * Represents the reason why a model finished generation of a response.
 *
 * Possible finish reasons:
 * - `"stop"`: The model generated a stop sequence.
 * - `"length"`: The model exceeded its token budget.
 * - `"content-filter"`: The model generated content which violated a content filter.
 * - `"tool-calls"`: The model triggered a tool call.
 * - `"error"`: The model encountered an error.
 * - `"other"`: The model stopped for a reason not supported by this protocol.
 * - `"unknown"`: The model did not specify a finish reason.
 *
 * @since 1.0.0
 * @category Models
 */
export const FinishReason: Schema.Literal<[
  "stop",
  "length",
  "content-filter",
  "tool-calls",
  "error",
  "other",
  "unknown"
]> = Schema.Literal(
  "stop",
  "length",
  "content-filter",
  "tool-calls",
  "error",
  "other",
  "unknown"
).annotations({ identifier: "@effect/ai/AiResponse/FinishPart/FinishReason" })

/**
 * @since 1.0.0
 * @category Models
 */
export type FinishReason = typeof FinishReason.Type

/**
 * Represents information about the number of tokens used by the model to
 * generate a response.
 *
 * @since 1.0.0
 * @category Models
 */
export class Usage extends Schema.Class<Usage>(
  "@effect/ai/AiResponse/FinishPart/Usage"
)({
  /**
   * The number of tokens sent in the request to the model.
   */
  inputTokens: Schema.Int,
  /**
   * The number of tokens that the model generated for the request.
   */
  outputTokens: Schema.Int,
  /**
   * The number of reasoning tokens that the model used to generate the output
   * for the request.
   */
  reasoningTokens: Schema.Int,
  /**
   * The number of input tokens read from the prompt cache for the request.
   */
  cacheReadInputTokens: Schema.Int,
  /**
   * The number of input tokens written to the prompt cache for the request.
   */
  cacheWriteInputTokens: Schema.Int
}) {
  /**
   * The total of number of input tokens and output tokens generated by the
   * model.
   *
   * @since 1.0.0
   */
  get totalTokens(): number {
    return this.inputTokens + this.outputTokens
  }
}

/**
 * Represents additional provider-specific metadata that was returned by the
 * model.
 *
 * The outer record is keyed by provider name, while the inner record is keyed
 * by the names of the provider-specific metadata properties.
 *
 * ```ts
 * {
 *   "amazon-bedrock": {
 *     trace: { ... }
 *   }
 * }
 * ```
 *
 * @since 1.0.0
 * @category Models
 */
export const ProviderMetadata: Schema.Record$<
  typeof Schema.String,
  Schema.Record$<typeof Schema.String, typeof Schema.Unknown>
> = InternalCommon.ProviderMetadata

/**
 * Represents the final part of a response generated by a large language model.
 *
 * Contains useful information such as tokens used as part of the interaction
 * with the model.
 *
 * @since 1.0.0
 * @category Models
 */
export class FinishPart extends Schema.TaggedClass<FinishPart>(
  "@effect/ai/AiResponse/FinishPart"
)("Finish", {
  usage: Usage,
  reason: FinishReason,
  providerMetadata: Schema.optional(ProviderMetadata)
}) {}

/**
 * Represents the individual parts of a response generated by a large language
 * model.
 *
 * @since 1.0.0
 * @category Models
 */
export type Part =
  | TextPart
  | ReasoningPart
  | RedactedReasoningPart
  | ToolCallPart
  | ResponseMetadataPart
  | FinishPart

/**
 * @since 1.0.0
 * @category Models
 */
export const Part: Schema.Union<[
  typeof TextPart,
  typeof ReasoningPart,
  typeof RedactedReasoningPart,
  typeof ToolCallPart,
  typeof ResponseMetadataPart,
  typeof FinishPart
]> = Schema.Union(
  TextPart,
  ReasoningPart,
  RedactedReasoningPart,
  ToolCallPart,
  ResponseMetadataPart,
  FinishPart
).annotations({ identifier: "@effect/ai/AiResponse/AiResponsePart" })

/**
 * @since 1.0.0
 * @category tools
 */
export const WithStructuredOutputTypeId: unique symbol = Symbol("@effect/ai/AiResponse/WithStructuredOutputTypeId")

/**
 * @since 1.0.0
 * @category tools
 */
export type WithStructuredOutputTypeId = typeof WithStructuredOutputTypeId

/**
 * Represents an enhanced `AiResponse` that includes the structured output
 * generated by the model.
 *
 * @since 1.0.0
 * @category Models
 */
export class WithStructuredOutput<A> extends Data.Class<{
  /**
   * The initial response produced by the model.
   */
  readonly response: AiResponse
  /**
   * The identifier of the tool which generated this structured output.
   */
  readonly toolCallId: ToolCallId
  /**
   * The name of the tool which generated this structured output.
   */
  readonly toolName: string
  /**
   * The structured output generated by the model.
   */
  readonly value: A
}> {
  /**
   * @since 1.0.0
   */
  readonly [WithStructuredOutputTypeId]: WithStructuredOutputTypeId = WithStructuredOutputTypeId

  /**
   * @since 1.0.0
   */
  static is<A>(u: unknown): u is WithStructuredOutput<A> {
    return Predicate.hasProperty(u, WithStructuredOutputTypeId)
  }
}

/**
 * @since 1.0.0
 * @category tools
 */
export const WithToolCallResultsTypeId: unique symbol = Symbol("@effect/ai/AiResponse/WithToolCallResultsTypeId")

/**
 * @since 1.0.0
 * @category tools
 */
export type WithToolCallResultsTypeId = typeof WithToolCallResultsTypeId

/**
 * Represents an enhanced `AiResponse` that includes the results of any tool
 * call requests generated by the large language model.
 *
 * @since 1.0.0
 * @category Models
 */
export class WithToolCallResults<A> extends Data.Class<{
  /**
   * The initial response produced by the model.
   *
   * Useful for allowing incorporation of tool call results into subsequent
   * calls to the large language model.
   */
  readonly response: AiResponse
  /**
   * The tool call results, represented as a mapping between the tool call
   * identifier and the result of the tool call handler.
   */
  readonly results: ReadonlyMap<ToolCallId, A>
  /**
   * The encoded tool call results, suitable for incorporation into subsequent
   * requests to the large language model.
   */
  readonly encodedResults: ReadonlyMap<ToolCallId, unknown>
}> {
  /**
   * @since 1.0.0
   */
  readonly [WithToolCallResultsTypeId]: WithToolCallResultsTypeId = WithToolCallResultsTypeId

  /**
   * @since 1.0.0
   */
  static is<A>(u: unknown): u is WithToolCallResults<A> {
    return Predicate.hasProperty(u, WithToolCallResultsTypeId)
  }
}
