/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array"
import type * as Context from "effect/Context"
import { dual } from "effect/Function"
import * as Option from "effect/Option"
import * as Predicate from "effect/Predicate"
import * as Schema from "effect/Schema"
import * as AiResponse from "./AiResponse.js"
import type * as AiTool from "./AiTool.js"
import * as InternalCommon from "./internal/common.js"

const constDisableValidation: Schema.MakeOptions = { disableValidation: true }

// =============================================================================
// Provider Options
// =============================================================================

/**
 * A record containing all valid provider option keys which can be used to
 * extract provider-specific options from components of a prompt.
 *
 * @since 1.0.0
 * @category Provider Options
 */
export const ProviderOptions = {
  // Messages
  SystemMessage: "@effect/ai/AiPrompt/ProviderOptions/SystemMessage",
  UserMessage: "@effect/ai/AiPrompt/ProviderOptions/UserMessage",
  AssistantMessage: "@effect/ai/AiPrompt/ProviderOptions/AssistantMessage",
  ToolMessage: "@effect/ai/AiPrompt/ProviderOptions/ToolMessage",
  // Parts
  TextPart: "@effect/ai/AiPrompt/ProviderOptions/TextPart",
  FilePart: "@effect/ai/AiPrompt/ProviderOptions/FilePart",
  ReasoningPart: "@effect/ai/AiPrompt/ProviderOptions/ReasoningPart",
  ToolCallPart: "@effect/ai/AiPrompt/ProviderOptions/ToolCallPart",
  ToolCallResultPart: "@effect/ai/AiPrompt/ProviderOptions/ToolCallResultPart"
} as const satisfies Record<string, ProviderOptions.AllKeys>

/**
 * A utility type to extract provider-specific options from a record at the
 * specified key.
 *
 * @since 1.0.0
 * @category Utility Types
 */
export type ExtractProviderOptions<
  Options extends Record<string, any>,
  Key extends ProviderOptions.AllKeys
> = Key extends keyof Options ? Options[Key] : never

/**
 * @since 1.0.0
 */
export declare namespace ProviderOptions {
  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type AllKeys =
    // Messages
    | SystemMessage
    | UserMessage
    | AssistantMessage
    | ToolMessage
    // Parts
    | TextPart
    | FilePart
    | ReasoningPart
    | ToolCallPart
    | ToolCallResultPart

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type SystemMessage = "@effect/ai/AiPrompt/ProviderOptions/SystemMessage"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type UserMessage = "@effect/ai/AiPrompt/ProviderOptions/UserMessage"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type AssistantMessage = "@effect/ai/AiPrompt/ProviderOptions/AssistantMessage"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type ToolMessage = "@effect/ai/AiPrompt/ProviderOptions/ToolMessage"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type TextPart = "@effect/ai/AiPrompt/ProviderOptions/TextPart"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type FilePart = "@effect/ai/AiPrompt/ProviderOptions/FilePart"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type ReasoningPart = "@effect/ai/AiPrompt/ProviderOptions/ReasoningPart"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type ToolCallPart = "@effect/ai/AiPrompt/ProviderOptions/ToolCallPart"

  /**
   * @since 1.0.0
   * @category Provider Option Keys
   */
  export type ToolCallResultPart = "@effect/ai/AiPrompt/ProviderOptions/ToolCallResultPart"
}

// =============================================================================
// Parts
// =============================================================================

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const PartTypeId: unique symbol = Symbol.for("@effect/ai/AiPrompt/Part")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type PartTypeId = typeof PartTypeId

/**
 * Represents the identifier generated by a model when a tool call is requested.
 *
 * @since 1.0.0
 * @category Models
 */
export const ToolCallId: Schema.brand<typeof Schema.String, "@effect/ai/ToolCallId"> = InternalCommon.ToolCallId

/**
 * @since 1.0.0
 * @category Models
 */
export type ToolCallId = typeof ToolCallId.Type

/**
 * Represents the base part type which all other parts inherit from.
 *
 * @since 1.0.0
 * @category Parts
 */
export abstract class BasePart extends Schema.Class<BasePart>(
  "@effect/ai/AiPrompt/BasePart"
)({
  /**
   * Additional provider-specific options which will be passed through to the
   * provider integration and used to enable provider-specific behavior.
   */
  providerOptions: Schema.optionalWith(
    Schema.Record({
      key: Schema.String,
      value: Schema.Record({
        key: Schema.String,
        value: Schema.Unknown
      })
    }),
    { default: () => ({}) }
  )
}) {
  /**
   * @since 1.0.0
   */
  readonly [PartTypeId] = PartTypeId

  /**
   * Gets the provider-specific options for this part of the prompt, if present.
   */
  abstract getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.AllKeys>>

  /**
   * Sets the provider-specific options for this part of the prompt.
   */
  abstract setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.AllKeys>
  ): BasePart
}

/**
 * Represents a text part of a prompt which contains a string of text.
 *
 * @since 1.0.0
 * @category Parts
 */
export class TextPart extends BasePart.extend<TextPart>(
  "@effect/ai/AiPrompt/TextPart"
)({
  type: Schema.tag("text"),
  /**
   * The text content of the part.
   */
  text: Schema.String
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.TextPart>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.TextPart>
  ): TextPart {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new TextPart({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a file part of a prompt which contains data for a file as either
 * a `Uint8Array`, a base64 encoded string, or a `URL` to the file.
 *
 * @since 1.0.0
 * @category Parts
 */
export class FilePart extends BasePart.extend<FilePart>(
  "@effect/ai/AiPrompt/FilePart"
)({
  type: Schema.tag("file"),
  /**
   * The IANA media type of the file.
   *
   * This can also be a wildcard (e.g. `"image/*"`), in which case the provider
   * implementation must take the appropriate steps to handle the wildcard.
   *
   * @see https://www.iana.org/assignments/media-types/media-types.xhtml
   */
  mediaType: Schema.String,
  /**
   * The file data as either a `Uint8Array`, a base64 encoded string, or a
   * `URL` to the file.
   */
  data: Schema.Union(
    Schema.String,
    Schema.Uint8ArrayFromSelf,
    Schema.URLFromSelf
  ),
  /**
   * An optional name for the file.
   */
  filename: Schema.optional(Schema.String)
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.FilePart>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.FilePart>
  ): FilePart {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new FilePart({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a reasoning part of the prompt which contains reasoning text
 * generated by the large language model.
 *
 * @since 1.0.0
 * @category Parts
 */
export class ReasoningPart extends BasePart.extend<ReasoningPart>(
  "@effect/ai/AiPrompt/ReasoningPart"
)({
  type: Schema.tag("reasoning"),
  /**
   * The reasoning text generated by the large language model.
   */
  text: Schema.String
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.ReasoningPart>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.ReasoningPart>
  ): ReasoningPart {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new ReasoningPart({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a tool call part of the prompt which indicates a tool that the
 * large language model requested. The result of the tool call is used to
 * augment the large language model's final response.
 *
 * @since 1.0.0
 * @category Parts
 */
export class ToolCallPart extends BasePart.extend<ToolCallPart>(
  "@effect/ai/AiPrompt/ToolCallPart"
)({
  type: Schema.tag("tool-call"),
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  id: ToolCallId,
  /**
   * The name of the tool to call.
   */
  name: Schema.String,
  /**
   * The parameters to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  params: Schema.Unknown,
  /**
   * The mode in which this tool call will be executed.
   * - `"client"`: indicates that the tool call will be executed by the
   *   client application
   * - `"server"`: indicates that the tool call will be executed by the large
   *   language model provider
   *
   * If this property is not set, the `mode` of tool call execution will
   * default to `"client"`.
   */
  mode: Schema.optionalWith(
    Schema.Literal("client", "server"),
    { default: () => "client" as const }
  )
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.ToolCallPart>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.ToolCallPart>
  ): ToolCallPart {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new ToolCallPart({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a tool call result which is included in the prompt to allow the
 * large language model to incorporate the result into its next response.
 *
 * @since 1.0.0
 * @category Parts
 */
export class ToolCallResultPart extends BasePart.extend<ToolCallResultPart>(
  "@effect/ai/AiPrompt/ToolCallResultPart"
)({
  type: Schema.tag("tool-result"),
  /**
   * The identifier of the tool call with which this tool call result is
   * associated.
   */
  id: ToolCallId,
  /**
   * The name of the tool call with which this tool call result is associated.
   */
  name: Schema.String,
  /**
   * The pre-encoded result of the tool call as a JSON-serializable value.
   */
  result: Schema.Unknown
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.ToolCallResultPart>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.ToolCallResultPart>
  ): ToolCallResultPart {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new ToolCallResultPart({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents all message parts.
 *
 * @since 1.0.0
 * @category Parts
 */
export const Part: Schema.Union<[
  typeof TextPart,
  typeof FilePart,
  typeof ReasoningPart,
  typeof ToolCallPart,
  typeof ToolCallResultPart
]> = Schema.Union(
  TextPart,
  FilePart,
  ReasoningPart,
  ToolCallPart,
  ToolCallResultPart
)
/**
 * @since 1.0.0
 * @category Parts
 */
export type Part = typeof Part.Type

/**
 * @since 1.0.0
 * @category Guards
 */
export const isPart = (u: unknown): u is Part => Predicate.hasProperty(u, PartTypeId)

/**
 * Represents user message parts.
 *
 * @since 1.0.0
 * @category Parts
 */
export const UserMessagePart: Schema.Union<[
  typeof TextPart,
  typeof FilePart
]> = Schema.Union(
  TextPart,
  FilePart
)
/**
 * @since 1.0.0
 * @category Parts
 */
export type UserMessagePart = typeof UserMessagePart.Type

/**
 * Represents assistant message parts.
 *
 * @since 1.0.0
 * @category Parts
 */
export const AssistantMessagePart: Schema.Union<[
  typeof TextPart,
  typeof FilePart,
  typeof ReasoningPart,
  typeof ToolCallPart,
  typeof ToolCallResultPart
]> = Schema.Union(
  TextPart,
  FilePart,
  ReasoningPart,
  ToolCallPart,
  ToolCallResultPart
)
/**
 * @since 1.0.0
 * @category Parts
 */
export type AssistantMessagePart = typeof AssistantMessagePart.Type

/**
 * Represents tool message parts.
 *
 * @since 1.0.0
 * @category Parts
 */
export const ToolMessagePart: typeof ToolCallResultPart = ToolCallResultPart
/**
 * @since 1.0.0
 * @category Parts
 */
export type ToolMessagePart = typeof ToolMessagePart.Type

// =============================================================================
// Messages
// =============================================================================

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const MessageTypeId: unique symbol = Symbol.for("@effect/ai/AiPrompt/Message")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type MessageTypeId = typeof MessageTypeId

/**
 * Represents the base message type which all other messages inherit from.
 *
 * @since 1.0.0
 * @category Messages
 */
export abstract class BaseMessage extends Schema.Class<BaseMessage>(
  "@effect/ai/AiPrompt/BaseMessage"
)({
  /**
   * Additional provider-specific options which will be passed through to the
   * provider integration and used to enable provider-specific behavior.
   */
  providerOptions: Schema.optionalWith(
    Schema.Record({
      key: Schema.String,
      value: Schema.Record({
        key: Schema.String,
        value: Schema.Unknown
      })
    }),
    { default: () => ({}) }
  )
}) {
  /**
   * @since 1.0.0
   */
  readonly [MessageTypeId] = MessageTypeId

  /**
   * Gets the provider-specific options for this message within the prompt, if
   * present.
   */
  abstract getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.AllKeys>>

  /**
   * Sets the provider-specific options for this message within the prompt.
   */
  abstract setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.AllKeys>
  ): BaseMessage
}

/**
 * Represents a user-generated system message to include as part of a prompt.
 *
 * @since 1.0.0
 * @category Messages
 */
export class SystemMessage extends BaseMessage.extend<SystemMessage>(
  "@effect/ai/AiPrompt/SystemMessage"
)({
  role: Schema.tag("system"),
  /**
   * The content of the message.
   */
  content: Schema.String
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.SystemMessage>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.SystemMessage>
  ): SystemMessage {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new SystemMessage({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a user-generated message to include as part of a prompt.
 *
 * @since 1.0.0
 * @category Messages
 */
export class UserMessage extends BaseMessage.extend<UserMessage>(
  "@effect/ai/AiPrompt/UserMessage"
)({
  role: Schema.tag("user"),
  /**
   * The content of the message.
   */
  content: Schema.Array(UserMessagePart)
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.UserMessage>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.UserMessage>
  ): UserMessage {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new UserMessage({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a message generated by the large language model to include as
 * part of a prompt.
 *
 * @since 1.0.0
 * @category Messages
 */
export class AssistantMessage extends BaseMessage.extend<AssistantMessage>(
  "@effect/ai/AiPrompt/AssistantMessage"
)({
  role: Schema.tag("assistant"),
  /**
   * The content of the message.
   */
  content: Schema.Array(AssistantMessagePart)
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.AssistantMessage>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.AssistantMessage>
  ): AssistantMessage {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new AssistantMessage({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents a message generated as a result of tool calling to include as
 * part of a prompt.
 *
 * @since 1.0.0
 * @category Messages
 */
export class ToolMessage extends BaseMessage.extend<ToolMessage>(
  "@effect/ai/AiPrompt/ToolMessage"
)({
  role: Schema.tag("tool"),
  /**
   * The content of the message.
   */
  content: Schema.Array(ToolMessagePart)
}) {
  getProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>
  ): Option.Option<ExtractProviderOptions<Options, ProviderOptions.ToolMessage>> {
    return Option.fromNullable(this.providerOptions[tag.key]) as any
  }

  setProviderOptions<Identifier, Options extends Record<string, any>>(
    tag: Context.Tag<Identifier, Options>,
    options: ExtractProviderOptions<Options, ProviderOptions.ToolMessage>
  ): ToolMessage {
    const providerOptions = { ...this.providerOptions, [tag.key]: options }
    return new ToolMessage({ ...this, providerOptions }, constDisableValidation)
  }
}

/**
 * Represents the different types of messages which can be included as part of
 * a prompt to a large language model provider.
 *
 * @since 1.0.0
 * @category Messages
 */
export const Message: Schema.Union<[
  typeof SystemMessage,
  typeof UserMessage,
  typeof AssistantMessage,
  typeof ToolMessage
]> = Schema.Union(
  SystemMessage,
  UserMessage,
  AssistantMessage,
  ToolMessage
)
/**
 * @since 1.0.0
 * @category Messages
 */
export type Message = typeof Message.Type

/**
 * @since 1.0.0
 * @category Guards
 */
export const isMessage = (u: unknown): u is Message => Predicate.hasProperty(u, MessageTypeId)

// =============================================================================
// Prompt
// =============================================================================

/**
 * @since 1.0.0
 * @category Type Ids
 */
export const TypeId: unique symbol = Symbol.for("@effect/ai/AiPrompt")

/**
 * @since 1.0.0
 * @category Type Ids
 */
export type TypeId = typeof TypeId

/**
 * Represents a prompt which can be issued to a large language model provider.
 *
 * Not all large language model providers support multi-model inputs and / or
 * tool calls. The validation happens at runtime and an error will be returned
 * in such cases.
 *
 * @since 1.0.0
 * @category Prompt
 */
export class AiPrompt extends Schema.Class<AiPrompt>(
  "@effect/ai/AiPrompt"
)({
  /**
   * The content of the prompt represented as an array of messages which can
   * either be user-generated, model-generated, or generated as a result of
   * tool calls.
   */
  content: Schema.Array(Message)
}) {}

/**
 * @since 1.0.0
 * @category Guards
 */
export const isPrompt = (u: unknown): u is AiPrompt => Predicate.hasProperty(u, TypeId)

/**
 * A `Schema` which allows encoding / decoding an `AiPrompt` to / from JSON.
 *
 * @since 1.0.0
 * @category Prompt
 */
export const FromJson = Schema.parseJson(AiPrompt)

/**
 * @since 1.0.0
 * @category Models
 */
export type FromJson = typeof FromJson.Type

/**
 * An empty prompt.
 *
 * @since 1.0.0
 * @category Constructors
 */
export const empty: AiPrompt = new AiPrompt({ content: [] }, constDisableValidation)

/**
 * Represents raw input types which can be converted into an `AiPrompt`.
 *
 * @since 1.0.0
 * @category Models
 */
export type RawInput =
  | string
  | Iterable<typeof Message.Encoded>
  | AiPrompt
  | AiResponse.AiResponse
  | AiResponse.WithStructuredOutput<any>
  | AiResponse.WithToolCallResults<Record<string, AiTool.Any>>

const decodePrompt = Schema.decodeSync(AiPrompt)

/**
 * Constructs a new `AiPrompt` from raw input.
 *
 * @since 1.0.0
 * @category Constructors
 */
export const make = (input: RawInput): AiPrompt => {
  // string
  if (Predicate.isString(input)) {
    const textPart = new TextPart({ text: input }, constDisableValidation)
    const message = new UserMessage({ content: [textPart] }, constDisableValidation)
    return new AiPrompt({ content: [message] }, constDisableValidation)
  }

  // AiPrompt
  if (isPrompt(input)) {
    return new AiPrompt({ content: input.content.slice() }, constDisableValidation)
  }

  // AiResponse
  if (AiResponse.hasStructuredOutput(input)) {
    const assistantMessages = responseToMessages(input)
    const toolResultPart = new ToolCallResultPart({
      id: input.id,
      name: input.name,
      result: input.value
    }, constDisableValidation)
    const toolMessage = new ToolMessage({ content: [toolResultPart] }, constDisableValidation)
    return new AiPrompt({ content: Arr.append(assistantMessages, toolMessage) }, constDisableValidation)
  }
  if (AiResponse.hasToolCallResults(input)) {
    const assistantMessages = responseToMessages(input)
    const toolResultParts: Array<ToolCallResultPart> = []
    for (const [id, { name, result }] of input.encodedResults) {
      toolResultParts.push(new ToolCallResultPart({ id, name, result }, constDisableValidation))
    }
    const toolMessage = new ToolMessage({ content: toolResultParts }, constDisableValidation)
    return new AiPrompt({ content: Arr.append(assistantMessages, toolMessage) }, constDisableValidation)
  }
  if (AiResponse.isResponse(input)) {
    const assistantMessages = responseToMessages(input)
    return new AiPrompt({ content: assistantMessages }, constDisableValidation)
  }

  return decodePrompt({ content: Array.from(input) }, { errors: "all" })
}

const EXCLUDED_RESPONSE_PARTS = {
  "metadata": true,
  "text": false,
  "file": true,
  "reasoning": false,
  "tool-call": false,
  "tool-result": false,
  "source": true,
  "finish": true
} as const satisfies Record<AiResponse.Part["type"], boolean>

type ExcludedResponseParts = typeof EXCLUDED_RESPONSE_PARTS

type ValidResponsePart = {
  [PartType in keyof ExcludedResponseParts]: ExcludedResponseParts[PartType] extends false
    ? Extract<AiResponse.Part, { type: PartType }>
    : never
}[keyof ExcludedResponseParts]

const isValidResponsePart = (part: AiResponse.Part): part is ValidResponsePart => EXCLUDED_RESPONSE_PARTS[part.type]

const responseToMessages = (response: AiResponse.AiResponse): ReadonlyArray<Message> => {
  if (response.parts.length === 0) {
    return Arr.empty()
  }

  const content = Arr.filterMap(response.parts, (part): Option.Option<AssistantMessagePart> => {
    if (isValidResponsePart(part)) {
      switch (part.type) {
        case "text": {
          return Option.some(
            new TextPart({
              text: part.text
            }, constDisableValidation)
          )
        }

        case "reasoning": {
          return Option.some(
            new ReasoningPart({
              text: part.text
            }, constDisableValidation)
          )
        }

        case "tool-call": {
          return Option.some(
            new ToolCallPart({
              id: part.id,
              name: part.name,
              mode: part.mode,
              params: part.params
            }, constDisableValidation)
          )
        }

        case "tool-result": {
          return Option.some(
            new ToolCallResultPart({
              id: part.id,
              name: part.name,
              result: part.result
            }, constDisableValidation)
          )
        }
      }
    }
    return Option.none()
  })

  return [new AssistantMessage({ content }, constDisableValidation)]
}

/**
 * Merges the messages of one `AiPrompt` with the messages of another, creating
 * a new `AiPrompt` with the messages from both.
 *
 * @since 1.0.0
 * @category Combination
 */
export const merge: {
  (other: AiPrompt): (self: AiPrompt) => AiPrompt
  (self: AiPrompt, other: AiPrompt): AiPrompt
} = dual<
  (other: AiPrompt) => (self: AiPrompt) => AiPrompt,
  (self: AiPrompt, other: AiPrompt) => AiPrompt
>(2, (self, other) =>
  new AiPrompt({
    content: Arr.appendAll(self.content, other.content)
  }, constDisableValidation))
