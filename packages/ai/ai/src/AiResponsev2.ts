import * as Brand from "effect/Brand"
import * as Data from "effect/Data"
import type * as AiTool from "./AiTool.js"

/**
 * Represents a response received from a large language model.
 *
 * @since 1.0.0
 * @category Models
 */
export interface AiResponse<Tool extends AiTool.Any> {
  readonly parts: ReadonlyArray<Part<Tool>>
}

/**
 * Represents an single part of a response received from a large language model.
 *
 * @since 1.0.0
 * @category Models
 */
export type Part<Tool extends AiTool.Any> =
  | TextPart
  | ReasoningPart
  | RedactedReasoningPart
  | ToolCallPart<Tool>
  | ToolCallResultPart<Tool>
  | MetadataPart
  | FinishPart

/**
 * Represents part of the text generated by the model.
 *
 * @since 1.0.0
 * @category Models
 */
export class TextPart extends Data.TaggedClass("TextPart")<{
  /**
   * The text content generated by the model.
   */
  readonly text: string
  /**
   * The annotations used to support the text generated by the model.
   */
  // TODO
  // readonly annotations:
}> { }

/**
 * Represents part of the reasoning carried out by the model to generate a
 * response.
 *
 * @since 1.0.0
 * @category Models
 */
export class ReasoningPart extends Data.TaggedClass("ReasoningPart")<{
  /**
   * The reasoning content that the model used to return the output.
   */
  readonly reasoningText: string
  /**
   * An optional signature which verifies that the reasoning text was generated
   * by the model.
   */
  readonly signature?: string | undefined
}> { }

/**
 * Represents part of the reasoning carried out by the model to generate a
 * response which needed to be encrypted by the model provider for safety
 * reasons.
 *
 * @since 1.0.0
 * @category Models
 */
export class RedactedReasoningPart extends Data.TaggedClass("RedactedReasoningPart")<{
  /**
   * The content in the reasoning that was encrypted by the model provider for
   * safety reasons.
   */
  readonly redactedText: string
}> { }

/**
 * Represents the identifier generated by a model when a tool call is requested.
 *
 * @since 1.0.0
 * @category Models
 */
export const ToolCallId = Brand.nominal<ToolCallId>()

/**
 * @since 1.0.0
 * @category Models
 */
export type ToolCallId = string & Brand.Branded<string, "@effect/ai/ToolCallId">

/**
 * Represents a request by a model to call a specific tool that it has been
 * provided with.
 *
 * @since 1.0.0
 * @category Models
 */
export class ToolCallPart<Tool extends AiTool.Any> extends Data.TaggedClass("ToolCallPart")<{
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  readonly id: ToolCallId
  /**
   * The name of the tool to call.
   */
  readonly name: string
  /**
   * The arguments to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  readonly params: unknown
}> { }

/**
 * Represents a the result of resolving a particular tool invoked by a model.
 *
 * @since 1.0.0
 * @category Models
 */
export class ToolCallResultPart<Tool extends AiTool.Any> extends Data.TaggedClass("ToolCallResultPart")<{
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  readonly id: ToolCallId
  /**
   * The name of the tool to call.
   */
  readonly name: string
  /**
   * The arguments to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  readonly params: unknown
  /**
   * The result returned by the tool call handler.
   */
  readonly result: AiTool.Success<Tool>
  /**
   * The result returned by the tool call handler encoded into a format suitable
   * for incorporation into subsequent requests to the large language model.
   */
  readonly encodedResult: unknown
}> { }

/**
 * Represents the initial response metadata generated by a model when responding
 * to a request.
 *
 * @since 1.0.0
 * @categor Models
 */
export class MetadataPart extends Data.TaggedClass("MetadataPart")<{
  /**
   * The unique identifier for the response. Each chunk of the response should
   * have the same identifier.
   */
  readonly id?: string | undefined
  /**
   * The model that was used to generate the response.
   */
  readonly model: string
  /**
   * The Unix timestamp of when the model began generated the response.
   */
  readonly timestamp?: number | undefined
}> { }

/**
 * Represents the reason why a model finished generation of a response.
 *
 * Possible finish reasons:
 * - `"stop"`: The model generated a stop sequence.
 * - `"length"`: The model exceeded its token budget.
 * - `"content-filter"`: The model generated content which violated a content filter.
 * - `"tool-calls"`: The model triggered a tool call.
 * - `"error"`: The model encountered an error.
 * - `"other"`: The model stopped for a reason not supported by this protocol.
 * - `"unknown"`: The model did not specify a finish reason.
 *
 * @since 1.0.0
 * @category Models
 */
export type FinishReason =
  | "stop"
  | "length"
  | "content-filter"
  | "tool-calls"
  | "error"
  | "other"
  | "unknown"

/**
 * Represents information about the number of tokens used by the model to
 * generate a response.
 *
 * @since 1.0.0
 * @category Models
 */
export class Usage extends Data.Class<{
  /**
   * The number of tokens sent in the request to the model.
   */
  readonly inputTokens: number
  /**
   * The number of tokens that the model generated for the request.
   */
  readonly outputTokens: number
  /**
   * The total of number of input tokens and output tokens generated by the
   * model.
   */
  readonly totalTokens: number
  /**
   * The number of reasoning tokens that the model used to generate the output
   * for the request.
   */
  readonly reasoningTokens: number
  /**
   * The number of input tokens read from the prompt cache for the request.
   */
  readonly cacheReadInputTokens: number
  /**
   * The number of input tokens written to the prompt cache for the request.
   */
  readonly cacheWriteInputTokens: number
}> { }

/**
 * Represents additional provider-specific metadata that was returned by the
 * model. Specific providers will use module augmentation to add their own
 * specific provider metadata.
 *
 * The outer record is keyed by provider name, while the inner record is keyed
 * by the names of the provider-specific metadata properties.
 *
 * For example:
 *
 * ```ts
 * const providerMeta = {
 *   "amazon-bedrock": {
 *     // Provider specific metadata
 *   }
 * }
 * ```
 *
 * @since 1.0.0
 * @category Models
 */
export interface ProviderMetadata { }

/**
 * Represents the final part of a response generated by a large language model.
 *
 * Contains useful information such as tokens used as part of the interaction
 * with the model.
 *
 * @since 1.0.0
 * @category Models
 */
export class FinishPart extends Data.TaggedClass("FinishPart")<{
  readonly _tag: "FinishPart"
  readonly usage: Usage
  readonly reason: FinishReason
  readonly providerMetadata: ProviderMetadata
}> { }
